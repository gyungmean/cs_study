# 가상메모리

## 메모리란?

> 프로세스 실행에 필요한 데이터 및 코드를 저장하는 장치

- 내부 기억장치인 주 기억장치와 외부 기억장치인 보조 기억장치로 나뉜다.
  - 내부 기억장치는 보통 CPU의 Cache, Register, RAM
  - 보조 기억장치는 HDD, SDD
  - 내부 기억장치의 읽기/쓰기 속도보다 보조 기억장치가 더 빠름

## 가상 메모리

> 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법

### 가상메모리 탄생 이유

실행되는 코드 전부를 물리 메모리에 존재시켜야 했고… 메모리 용량보다 큰 프로그램은 실행 시킬 수 없었다! 여러 프로그램을 동시에 메모리에 올리려면 용량의 한계와 페이지 교체 등의 성능 이슈 발생

가끔만 사용되는 코드가 메모리를 차지함… 불필요하게 메모리에 올라와있는 프로그램이 이빠이… ⇒ **_프로그램의 일부분만 메모리에 올릴 수 있다면???_**

**모든 데이터를 주 기억장치에 올리지 않고 필요한 것들만 올려서 사용하자**

가상 메모리의 장점

- 물리 메모리 크기에 제약받지 않게 됨
- 더 많은 프로그램을 동시 실행 가능
- 응답시간이 유지되고 cpu 이용률과 처리율은 높아짐

### 가상 메모리가 하는일

> 프로세스가 실제 메모리의 크기와 상관없이 메모리를 이용할 수 있도록 지원

실제의 물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것

작은 메모리를 가지고도 얼마든지 큰 가상주소공간을 프로그래머에게 제공

### 가상 메모리 동작 원리

프로세스가 차지하는 실제 메모리 공간만 물리 메모리(RAM)에 넣고, 이 물리 메모리에 접근할 수 있는 가상 주소를 프로세스 메모리에 저장한다.

1. 프로세스가 작업을 처리하기 위해 CPU호출
2. CPU는 작업을 처리하기 위해 특정 데이터를 호출
3. 특정 데이터는 물리 메모리 어디에 있지? -> 가상 주소로 알 수 있다
   **프로세스는 CPU에게 작업을 요청할 때 데이터의 가상 주소를 넘긴다**

실제 데이터는 큰 물리 공간을 차지하고 있겠지만 가상 메모리로 인해 아주 작은 메모리 공간을 차지하면서 실제 메모리와 연결이 가능하다.

## 가상 주소

### 가상 주소 공간

1. 가상 주소 공간은 **`프로세스가 참조하는 주소`**이다.
2. 프로세스가 요구하는 메모리 공간을 가상메모리에서 제공한다. 가상 주소는 **`논리적인 주소`**이기 때문에 이 주소를 **`필요한 크기의 물리 메모리 페이지로 매핑`**한다.
3. 만약 가상주소 없이 프로세서의 모든 데이터들을 물리 주소에 접근한다면? → 여러개의 프로세스가 실행 될때 같은 물리 주소 데이터를 수정하고 민감 데이터를 읽고 이러면 오류가 발생함
4. 프로세스마다 다른 가상 주소를 사용하면, 같은 물리 주소 위치를 가리키고 있을 수는 있음

하지만 읽고 쓰기는 가상 주소 공간에서만 이루어지므로 실제 물리 주소의 데이터들이 수정되거나 동시에 접근해서 충돌하는 사태는 발생하지 않음.

### 물리 주소

- 실제 메모리의 주소
- 하드웨어에서 직접 접근 가능
- 시스템 전체적으로 공유됨, 여러 프로세스가 공유 메모리 영역을 사용할 때 사용됨
- 프로세스가 물리 주소로 접근하려면, 물리 주소를 가리키고 있는 가상 주소를 물리 주소로 변환해야한다.

### MMU(Memory Management Unit)

![image](https://github.com/gyungmean/cs_study/assets/70059000/b206a9af-0c07-48f4-a76e-195abab9ce7f)
CPU는 프로세스에게 전달받은 가상 주소를 물리 주소로 변환시켜야한다. 그 때 사용하는 것이 MMU

- 가상 주소를 물리주소로 변환
- 메모리를 보호하는 기능 수행
- 굉장히 빈번하게 작업을 처리함, SW코드로만 이 작업을 하기엔 벅참, 그래서 이 관리 작업을 하는 특수한 하드웨어를 따로 컴퓨터에 설치함
- **일일이 모든 주소를 변환하면 작업 부하가 높아짐** 그래서 MMU는 실제 물리 메모리 공간을 페이지 단위로 나눠서 각 `**페이지 단위로 데이터를 처리**`한다.
